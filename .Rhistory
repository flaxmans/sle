makeStreams <- function( r, k, a12, a21, endTime = 500, npoints = 5, timePoints = 1000 ) {
timeVector <- seq(0, endTime, length.out = timePoints)
r1 <- r
r2 <- r
k1 <- k
k2 <- k
jump <- k/npoints
parms <- c(r1, k1, a12, r2, k2, a21)
vals <- seq(0.001, k, length.out = npoints)
for ( i in vals ) {
for ( j in vals ) {
n0 <- c(i, j)
solution <- ode( y = n0, times = timeVector, func = rateOfChange2, parms = parms)
lines(solution[,2], solution[,3], col = "green", lwd = 0.5)
}
}
}
nullClines(makeVF = F, addStreams = T, streamPoints = 12)\
nullClines(makeVF = F, addStreams = T, streamPoints = 12)
nullClines <- function(a12 = c(0.8, 1.2), a21 = c(0.7, 1.3), k = 1000, r = 0.2, makeVF = T, npoints = 20, addStreams = T, streamPoints = 5){
ptcol <- "magenta"
par(mfrow = c(1,length(a12)))
for ( i in 1:length(a12) ) {
# null cline for sp 2:
curve(expr = k - a12[i]*x, from = 0, to = k, col = "blue", xlab = "n1", ylab = "n2", ylim = c(0,k))
# null cline for sp 1:
curve(expr = (k-x)/a21[i], from = 0, to = k, col = "red", add = T)
n1eq <- (k - a21[i]*k)/(1 - a21[i]*a12[i])
n2eq <- (k - a12[i]*k)/(1 - a21[i]*a12[i])
points(n1eq, n2eq, pch = 19, col = ptcol, bg = ptcol)
title(main = paste("a12 = ", a12[i], ", a21 = ", a21[i], sep = ""))
if ( addStreams ) {
makeStreams(r, k, a12[i], a21[i], npoints = streamPoints)
}
if ( makeVF ) {
compLogisticArrows(a12[i], a21[i], k = k, r = r, npoints = npoints)
} else {
legend(0, 0.3*k, legend = c("species 1", "species 2"), col = c("red", "blue"), lty = c(1,1) )
}
}
}
nullClines(makeVF = F, addStreams = T, streamPoints = 12)
makeStreams <- function( r, k, a12, a21, endTime = 500, npoints = 5, timePoints = 1000 ) {
timeVector <- seq(0, endTime, length.out = timePoints)
r1 <- r
r2 <- r
k1 <- k
k2 <- k
parms <- c(r1, k1, a12, r2, k2, a21)
vals <- seq(k/100, k, length.out = npoints)
for ( i in vals ) {
for ( j in vals ) {
n0 <- c(i, j)
solution <- ode( y = n0, times = timeVector, func = rateOfChange2, parms = parms)
lines(solution[,2], solution[,3], col = "green", lwd = 0.5)
}
}
}
nullClines(makeVF = F, addStreams = T, streamPoints = 12)
nullClines(makeVF = T, npoints = 15, addStreams = T, streamPoints = 12)
?ode
p <- as.list(c(r1, k1, a12, r2, k2, a21))
p
names(p)
names(p) <- c("r1", "k1", "a12", "r2", "k2", "a21")
names(p)
p$r1
rm(list = ls())
myLogisticFunc <- function(y, t, parms) {
n <- y + y * parms$r * ( parms$k - y ) / parms$k
return( list(n) )
}
r <- 0.1
k <- 1000
logisticParms <- as.list(c(r, k))
names(logisticParms) <- c("r", "k")
times <- seq(from = 0, to = 100, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
n0 <- 10
times <- seq(from = 0, to = 100, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2])
times <- seq(from = 0, to = 200, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2])
par(mfrow = c(1,1))
plot(solution[,1], solution[,2])
myLogisticFunc <- function(y, t, parms) {
n <- y + y * parms$r * (( parms$k - y ) / parms$k)
return( list(n) )
}
r <- 0.1
k <- 1000
logisticParms <- as.list(c(r, k))
names(logisticParms) <- c("r", "k")
n0 <- 10
times <- seq(from = 0, to = 200, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2])
n <- y * parms$r * (( parms$k - y ) / parms$k)
myLogisticFunc <- function(y, t, parms) {
n <- y * parms$r * (( parms$k - y ) / parms$k)
return( list(n) )
}
r <- 0.1
k <- 1000
logisticParms <- as.list(c(r, k))
names(logisticParms) <- c("r", "k")
n0 <- 10
times <- seq(from = 0, to = 200, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2])
myLogisticFunc <- function(t, y, parms) {
n <- y * parms$r * (( parms$k - y ) / parms$k)
return( list(n) )
}
r <- 0.1
k <- 1000
logisticParms <- as.list(c(r, k))
names(logisticParms) <- c("r", "k")
n0 <- 10
times <- seq(from = 0, to = 200, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2])
myLogisticFunc <- function(t, y, parms) {
n <- y * parms$r * (( parms$k - y ) / parms$k)
return( list(n) )
}
r <- 0.1
k <- 1000
logisticParms <- as.list(c(r, k))
names(logisticParms) <- c("r", "k")
n0 <- 10
times <- seq(from = 0, to = 100, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticFunc, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2], type = "l")
myLogisticODE <- function(t, y, parms) {
n <- y * parms$r * (( parms$k - y ) / parms$k)
return( list(n) )
}
r <- 0.1
k <- 1000
logisticParms <- as.list(c(r, k))
names(logisticParms) <- c("r", "k")
n0 <- 10
times <- seq(from = 0, to = 100, by = 0.01)
solution <- ode(y = n0, times = times, func = myLogisticODE, parms = logisticParms)
dim(solution)
str(solution)
names(solution)
plot(solution[,1], solution[,2], type = "l")
plot(solution[,1], solution[,2], type = "l", xlab = "time", ylab = "abundance")
myLogisticODE <- function(t, y, parms) {
# to use with ode(), this function MUST have at
# least three arguments, and they MUST be in the order shown (t, y, parms)
# here is the ODE:
n <- y * parms$r * (( parms$k - y ) / parms$k)
# the function must return a list
return( list(n) )
}
myLogisticODE <- function(t, y, parms) {
# to use with ode(), this function MUST have at
# least three arguments, and they MUST be in the order shown (t, y, parms)
# here is the ODE:
dydt <- y * parms$r * (( parms$k - y ) / parms$k)
# the function must return a list
return( list(dydt) )
}
myLogisticODE <- function(t, y, parms) {
# to use with ode(), this function MUST have at
# least three arguments, and they MUST be in the order shown (t, y, parms)
# here is the ODE:
dydt <- y * parms$r * (( parms$k - y ) / parms$k)
# the function must return a list
return( list(dydt) )
}
# set parameters and intial conditions:
r <- 0.1 # intrinsic rate of increase
k <- 1000 # carrying capacity
logisticParms <- as.list(c(r, k))  # doesn't have to be a list, but this enables names
names(logisticParms) <- c("r", "k") # add names
n0 <- 10 # initial value
times <- seq(from = 0, to = 100, by = 0.01) # time vector
# call the ode solver:
solution <- ode(y = n0, times = times, func = myLogisticODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
competitionODE <- function(t, y, parms) {
#since this is a 2-D system, y should be a 2-element vector
# the ODEs:
dy1dt <- y[1] * parms$r1 * (( parms$k1 - y[1] - parms$a21*y[2] ) / parms$k1)
dy2dt <- y[2] * parms$r2 * (( parms$k2 - y[2] - parms$a12*y[1] ) / parms$k2)
# the function must return a list
return( list(c(dy1dt, dy2dt)) )
}
competitionODE <- function(t, y, parms) {
#since this is a 2-D system, y should be a 2-element vector
# the ODEs:
dy1dt <- y[1] * parms$r1 * (( parms$k1 - y[1] - parms$a21*y[2] ) / parms$k1)
dy2dt <- y[2] * parms$r2 * (( parms$k2 - y[2] - parms$a12*y[1] ) / parms$k2)
# the function must return a list
return( list(c(dy1dt, dy2dt)) )
}
# set parameters and intial conditions:
r1 <- 0.1 # intrinsic rate of increase
r2 <- r1 # make it the same for simplicity for now
k1 <- 1000 # carrying capacity
k2 <- k1 # make it the same for now for simplicity
a12 <- 0.8 # competition coefficients
a21 <- 0.7
logisticParms <- as.list(c(r1, k1, r2, k2, a12, a21))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
n0 <- c(10,20) # initial values
times <- seq(from = 0, to = 100, by = 0.01) # time vector
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
# graphics:
sp1col = "red"
sp2col = "blue"
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
times <- seq(from = 0, to = 200, by = 0.01) # time vector
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
# graphics:
sp1col = "red"
sp2col = "blue"
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
times <- seq(from = 0, to = 400, by = 0.01) # time vector
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
# graphics:
sp1col = "red"
sp2col = "blue"
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
compare two parameter cases:
# set parameters and intial conditions:
r1 <- 0.1 # intrinsic rate of increase
r2 <- r1 # make it the same for simplicity for now
k1 <- 1000 # carrying capacity
k2 <- k1 # make it the same for now for simplicity
a12 <- c(0.8, 1.3) # competition coefficients
a21 <- c(0.7, 1.2) #
n0 <- c(300,400) # initial values
times <- seq(from = 0, to = 400, by = 0.01) # time vector
for ( i in 1:length(a12) ) {
par(mfrow = c(1,length(a12)))
logisticParms <- as.list(c(r1, k1, r2, k2, a12[i], a21[i]))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
# graphics:
sp1col = "red"
sp2col = "blue"
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
title(main = paste("a12 = ", a12[i], ", a21 = ", a21[i], sep = ""))
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
}
r1 <- 0.1 # intrinsic rate of increase
r2 <- r1 # make it the same for simplicity for now
k1 <- 1000 # carrying capacity
k2 <- k1 # make it the same for now for simplicity
a12 <- c(0.8, 1.3) # competition coefficients
a21 <- c(0.7, 1.2) #
n0 <- c(300,400) # initial values
times <- seq(from = 0, to = 400, by = 0.01) # time vector
for ( i in 1:length(a12) ) {
par(mfrow = c(1,length(a12)))
logisticParms <- as.list(c(r1, k1, r2, k2, a12[i], a21[i]))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
# graphics:
sp1col = "red"
sp2col = "blue"
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
title(main = paste("a12 = ", a12[i], ", a21 = ", a21[i], sep = ""))
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
}
###########
# compare two parameter cases:
# set parameters and intial conditions:
r1 <- 0.1 # intrinsic rate of increase
r2 <- r1 # make it the same for simplicity for now
k1 <- 1000 # carrying capacity
k2 <- k1 # make it the same for now for simplicity
a12 <- c(0.8, 1.3) # competition coefficients
a21 <- c(0.7, 1.2) #
n0 <- c(300,400) # initial values
times <- seq(from = 0, to = 400, by = 0.01) # time vector
par(mfrow = c(1,length(a12)))
sp1col = "red"
sp2col = "blue"
for ( i in 1:length(a12) ) {
logisticParms <- as.list(c(r1, k1, r2, k2, a12[i], a21[i]))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# graphics:
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
title(main = paste("a12 = ", a12[i], ", a21 = ", a21[i], sep = ""))
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
}
r1 <- 0.1 # intrinsic rate of increase
r2 <- r1 # make it the same for simplicity for now
k1 <- 1000 # carrying capacity
k2 <- k1 # make it the same for now for simplicity
a12 <- c(0.8, 1.2) # competition coefficients
a21 <- c(0.7, 1.3) #
n0 <- c(300,400) # initial values
times <- seq(from = 0, to = 400, by = 0.01) # time vector
par(mfrow = c(1,length(a12)))
sp1col = "red"
sp2col = "blue"
for ( i in 1:length(a12) ) {
logisticParms <- as.list(c(r1, k1, r2, k2, a12[i], a21[i]))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# graphics:
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
title(main = paste("a12 = ", a12[i], ", a21 = ", a21[i], sep = ""))
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
}
for ( i in 1:length(a12) ) {
logisticParms <- as.list(c(r1, k1, r2, k2, a12[i], a21[i]))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# graphics:
plot(solution[,1], solution[,2], type = "l",
xlab = "time", ylab = "abundance", col = sp1col,
ylim = c(0,max(k1,k2)))
lines(solution[,1], solution[,3], col = sp2col)
title(main = paste("a12 = ", a12[i], ", a21 = ", a21[i], sep = ""))
if ( i == 1 ) {
legend(x = 0, y = min(k1,k2), legend = c("species 1", "species 2"),
lty = c(1,1), col = c(sp1col, sp2col))
}
}
r1 <- 0.1 # intrinsic rate of increase
r2 <- r1 # make it the same for simplicity for now
k1 <- 1000 # carrying capacity
k2 <- k1 # make it the same for now for simplicity
a12 <- 0.8 # competition coefficients
a21 <- 0.7
logisticParms <- as.list(c(r1, k1, r2, k2, a12, a21))
# add names. make sure order is correct compared to previous line!!
names(logisticParms) <- c("r1", "k1", "r2", "k2", "a12", "a21")
n0 <- c(10,20) # initial values
times <- seq(from = 0, to = 400, by = 0.01) # time vector
# call the ode solver:
solution <- ode(y = n0, times = times, func = competitionODE, parms = logisticParms)
# check out some properties of what you get back from the solver:
dim(solution)
str(solution)
rmultinom(n = 1, size = 10, prob = c(0.1, 0.2, 0.3, 0.4))
rmultinom(n = 1, size = 100, prob = c(0.1, 0.4, 0.4, 0.1))
library(deSolve)
init_vals <- c(15, 60)
names(init_vals) <- c('Predator', 'Prey')
time_seq <- seq(0,500, by=0.01)
params <- list(r = 0.25, c = 0.1, a = 0.01, m = 0.01)
# Now make a function for the differential equations
PredPreyDiffEQ <- function(t, y, parms){
# t and y are the required function arguments for compatability with ode()
# parms is a list of named parameter values.
dPdt <- parms$c * parms$a * y[1] * y[2] - parms$m * y[1]
dNdt <- parms$r * y[2] - parms$a * y[1] * y[2]
return(list(c(dPdt, dNdt)))      # Must return a list
}
results <- ode(y = init_vals, times = time_seq, func = PredPreyDiffEQ, parms = params)
dim(results)
head(results)
# Now make a plot of the results
quartz()
plot(x=NA, y=NA, xlim=c(0,500), ylim=c(0,max(results[,2:3])), xlab='Generation',
ylab='Abundance', main='', las=1, cex.axis=1.5, cex.lab=1.5, xaxs='i')
lines(x=results[,1], y=results[,'Predator'], col='darkred', lwd=1.5)
lines(x=results[,1], y=results[,'Prey'], col='darkgreen', lwd=1.5)
legend('topleft', legend=c('Predator', 'Prey'), col=c('darkred', 'darkgreen'),
lty=1, lwd=1.5, cex=1.5, inset=0.05, bty='n')
PredPrey <- function(Ninit = 60, Pinit = 15, r = 0.25, c = 0.1, a = 0.01, m = 0.01, gens = 500){
# Ninit is the starting abundance of the prey species
# Pinit is the starting abundance of the predator species
# r is the intrinsic growth rate for the prey
# a is the attack rate of predators on prey
# c is the conversion coefficient relating prey consumed to new predators produced
# m is the per capitat mortality rate of predators
# gens is the number of generations to run the model for
predator <- rep(NA, length(time))
time <- seq(0, gens)
predator[1] <- Pinit
prey <- rep(NA, length(time))
prey[1] <- Ninit
for(t in 1:gens){
# Loop through each generation and calculate the abundances of prey and predators
predator[t+1] <- predator[t] + c*a*prey[t]*predator[t] - m*predator[t]
prey[t+1] <- prey[t] + r*prey[t] - a*prey[t]*predator[t]
# Check to make sure neither specis is allowed to have negative abundances
if(prey[t+1] < 0){
prey[t + 1] <- 0
}
if(predator[t+1] < 0){
predator[t+1] <- 0
}
}
results <- data.frame(time, predator, prey)
# Plot the results in a single figure
# The quartz() call should be changed to windows() for PCs
quartz()
plot(x=NA, y=NA, xlim=c(0,gens), ylim=c(0,max(c(predator,prey))), xlab='Generation',
ylab='Abundance', main='', las=1, cex.axis=1.5, cex.lab=1.5, xaxs='i')
lines(x=time, y=predator, col='darkred', lwd=1.5)
lines(x=time, y=prey, col='darkgreen', lwd=1.5)
legend('topleft', legend=c('Predator', 'Prey'), col=c('darkred', 'darkgreen'),
lty=1, lwd=1.5, cex=1.5, inset=0.05)
# Return the results as a data frame
return(results)
}
results <- PredPrey()
#    Part (d)
# Use the ode() function to solve the differential equation model for the same
rm(list = ls())
install.packages("devtools")
install.packages("Geneland")
install.packages("~/Desktop/phybase", repos = NULL, type = "source")
install.packages("ape)
""
)
"
install.packages("ape")
install.packages("~/Desktop/phybase", repos = NULL, type = "source")
library("devtools")
library_github("radamsRHA/GppFST")
install_github("radamsRHA/GppFST")
cd('~/Dropbox/source/sle/')
setwd('~/Dropbox/source/sle/')
source('parameters.m')
BURN_IN_PERIOD
exit
exit()
quit()
